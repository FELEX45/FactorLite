## Глава 2. Проектирование и выбор технологий (проектирование решения)

### 2.1 Обоснование выбора технологического стека

Целью технологического выбора для проекта FactorLite является получение кроссплатформенного решения, позволяющего разрабатывать и отлаживать игровую логику в одном коде, а затем выпускать продукт на Android. Дополнительно важны производительность (целевой сценарий — стабильный кадр при большом количестве объектов), контролируемая работа с ресурсами (текстуры, шрифты, данные баланса) и быстрый цикл итераций по UI и балансу.

#### Выбор libGDX

В качестве основы выбран фреймворк **libGDX**, так как он:

- **кроссплатформенный**: одна кодовая база может запускаться на Android и Desktop, что упрощает сопровождение и снижает риск расхождения поведения по платформам;
- **производительный и предсказуемый**: предоставляет низкоуровневый доступ к рендеру и управлению ресурсами, что важно для жанра с высокой плотностью объектов (враги, снаряды, эффекты);
- **зрелый**: имеет стабильную экосистему, документацию и проверенные временем backend’ы (Android и LWJGL3 для Desktop).

Для FactorLite это означает, что ключевые подсистемы (прогрессия, бой, лут, таргетинг, состояния забега) реализуются в общем модуле и используются одинаково на обеих платформах, а различия выносятся в слой запуска (launcher).

#### Выбор Kotlin

Язык реализации — **Kotlin**, поскольку он:

- обеспечивает **высокую выразительность кода** и снижает “шум” в реализации игровых систем (меньше шаблонного кода по сравнению с Java);
- хорошо интегрируется с Gradle и Android‑инструментарием;
- поддерживает удобные модели данных и паттерны декомпозиции, полезные при переводе логики из “монолита” в набор подсистем.

Выбор Kotlin сочетается с требованиями Android‑платформы и позволяет использовать единый стиль разработки во всех модулях проекта.

#### Почему важен Desktop target (LWJGL3)

Отдельный Desktop‑таргет в FactorLite используется как “быстрый контур” разработки:

- **ускорение отладки**: запуск на ПК не требует установки APK и взаимодействия с устройством, что сокращает время между правкой кода и проверкой результата;
- **ускорение итераций баланса и UI**: изменения в числах и интерфейсе проще проверять при частых перезапусках и быстром доступе к логам/профилированию;
- **более удобные инструменты разработки**: легче использовать горячие клавиши, отладчик IDE и анализ производительности.

В проекте Desktop‑запуск оформлен отдельным модулем `lwjgl3`, который подключает backend LWJGL3 и использует общий модуль `core`. Быстрый запуск Desktop‑версии зафиксирован в корневом `README.md` как основной путь оперативной проверки изменений.

#### Итог: соответствие стека целям проекта

Комбинация **libGDX + Kotlin** даёт FactorLite следующие практические преимущества:

- единый слой игровой логики для Android и Desktop;
- быстрый цикл итераций благодаря Desktop‑раннеру;
- контроль производительности и ресурсов, критичный для *survivor-like*;
- удобную основу для расширяемости (добавление контента, настройка баланса, развитие UI) в рамках MVP и последующих версий.

### 2.2 Архитектура проекта и модульность

Проект FactorLite организован как **multi-module Gradle**‑репозиторий, где общая игровая логика изолирована от платформенных деталей запуска. Такой подход снижает дублирование кода и позволяет отлаживать один и тот же “core” как на Desktop, так и на Android.

#### Модульная структура

Репозиторий включает три основных модуля:

- **`core`** — общий модуль с игровой логикой и базовыми зависимостями libGDX. Здесь размещаются подсистемы забега, прогрессия, механики и UI‑логика, которые должны одинаково работать на всех платформах.
- **`lwjgl3`** — Desktop‑лаунчер и конфигурация запуска на ПК (backend LWJGL3). Модуль подключает `:core` и используется как основной “быстрый контур” для отладки и итераций.
- **`android`** — Android‑лаунчер и конфигурация сборки приложения. Модуль подключает `:core`, настраивает Android‑параметры (SDK, `applicationId`, версии) и упаковку платформенных зависимостей.

Разделение на модули позволяет:

- развивать игровые системы в одном месте (`core`), не переписывая их под платформы;
- иметь отдельные точки входа и конфигурации для Desktop и Android;
- ускорять разработку через Desktop‑раннер без потери совместимости с целевой платформой (Android).

#### Единый каталог `assets/` для обеих платформ

Для устранения дублирования ресурсов используется **единая папка `assets/` в корне репозитория**, подключаемая и для Desktop, и для Android:

- в **`lwjgl3`** папка `../assets` добавляется как `resources` Gradle‑source set (ресурсы попадают в classpath Desktop‑приложения);
- в **`android`** папка `../assets` добавляется как `assets` Android‑source set (ресурсы упаковываются в APK/AAB).

Единый источник ассетов гарантирует одинаковое содержимое ресурсов на всех платформах и упрощает жизненный цикл проекта: обновления текстур/шрифтов/данных не требуют синхронизации между модулями.

#### Принципы организации ресурсов

В проекте принята простая структура ассетов, ориентированная на расширяемость:

- **`assets/textures/`** — спрайты и графические ресурсы (PNG).
- **`assets/fonts/`** — шрифты (TTF/OTF), включая варианты для кириллицы.
- **`assets/sfx/`** — короткие звуковые эффекты.
- **`assets/data/`** — данные/конфиги (например, `balance.json`) для data-driven настройки.

Такое разделение обеспечивает:

- предсказуемые пути загрузки ресурсов в коде;
- удобство замены/добавления контента без изменения структуры проекта;
- прозрачную поддержку data-driven баланса через отдельный каталог данных.

### 2.3 Архитектура игрового цикла и управление состояниями

Центральным элементом игровой архитектуры FactorLite является экран `GameScreen`, который выполняет роль “оркестратора” забега: принимает ввод, обновляет подсистемы, переключает состояния и выполняет рендер мира и интерфейса. Такой подход характерен для MVP‑версии: вся логика жизненного цикла сосредоточена в одной точке входа, при этом внутренние механики вынесены в отдельные системы (бой, лут, таргетинг, прогрессия и т.д.).

#### Жизненный цикл забега

В ходе работы `GameScreen` проходит последовательность состояний:

- **выбор сложности** → **выбор персонажа** → **основной бой (RUNNING)**,
- периодические “остановки” на выбор: **LEVEL_UP** (апгрейды) и **SHRINE_OPEN** (глобальные бонусы),
- завершение забега: **VICTORY** или **GAME_OVER**,
- возможность перезапуска и возврата к стартовому выбору.

Важно, что в реализации **обновление мира выполняется только в состоянии `RUNNING`** (через вызов `update(delta)`), а в остальных состояниях мир “замораживается”, и игрок взаимодействует только с интерфейсом выбора/паузы/результата. При этом рендер кадра продолжает выполняться, что позволяет отображать оверлеи поверх текущей сцены.

#### Модель состояний (`RunState`) и её назначение

Состояния представлены перечислением `RunState` и используются как единый переключатель логики ввода, обновления и UI‑оверлеев. С практической точки зрения каждое состояние отвечает на вопросы: **какой ввод активен**, **какие подсистемы обновляются**, **какой интерфейс должен быть показан**.

Ниже приведено назначение ключевых состояний и их эффект на игровой цикл.

| Состояние | Назначение | Что блокируется | Что рендерится/показывается |
| --- | --- | --- | --- |
| `DIFFICULTY_SELECT` | Стартовый выбор сложности забега | Обновление мира (`update`) | Оверлей выбора сложности (карточки) поверх сцены |
| `CHARACTER_SELECT` | Выбор персонажа перед стартом | Обновление мира (`update`) | Оверлей выбора персонажа (карточки + иконки/описания) |
| `RUNNING` | Основной игровой режим | Ничего (мир обновляется) | Мир + HUD + джойстик (для мобильного ввода) |
| `PAUSED` | Быстрая остановка для прерываний | Обновление мира (`update`), активный ввод движения | Оверлей “PAUSE”, HUD (кнопка возобновления) |
| `LEVEL_UP` | Выбор улучшения “1 из 3” при получении уровня | Обновление мира (`update`) | Оверлей карточек улучшений поверх сцены |
| `SHRINE_OPEN` | Выбор глобального бонуса после события “святыня” | Обновление мира (`update`) | Оверлей бонусов + кнопка “Пропустить” |
| `VICTORY` | Завершение забега победой | Обновление мира (`update`) | Экран результата (надпись VICTORY) + подсказка перезапуска |
| `GAME_OVER` | Завершение забега поражением | Обновление мира (`update`) | Экран результата (GAME OVER) + подсказка перезапуска |

#### Что происходит при переходах (пример “остановок”)

Переходы в “оверлейные” состояния выполняются как реакция на события игровых систем:

- **LEVEL_UP**: после подбора XP и достижения порога уровень повышается, формируются 3 карточки улучшений и игра переключается в состояние выбора. Это обеспечивает “честную” паузу, в которой игрок принимает решение без давления со стороны времени.
- **SHRINE_OPEN**: при выполнении условия святыни система событий возвращает набор бонусов, после чего `GameScreen` переключается в оверлей выбора; основной бой при этом замораживается до выбора.

#### Примечание про `CHEST_OPEN`

В концептуальном плане жанра часто встречается отдельное состояние **`CHEST_OPEN`** (когда сундук открывается через UI‑выбор). В текущей реализации FactorLite сундуки открываются по близости при наличии золота и **сразу выдают случайный предмет без отдельного UI‑экрана**, поэтому отдельное состояние `CHEST_OPEN` не используется. При дальнейшем развитии проекта это состояние может быть добавлено, если потребуется интерфейс выбора награды или подтверждение покупки.

### 2.4 Проектирование ключевых подсистем (ответственность и взаимодействие)

Архитектура FactorLite построена как набор специализированных подсистем, которые решают конкретные задачи и взаимодействуют через данные и события. Роль центрального “координатора” выполняет `GameScreen`: он определяет порядок обновления, переключает состояния (`RunState`) и управляет тем, какие элементы ввода и UI активны в текущий момент.

#### Подсистема ввода и движения

- **Ответственность**: интерпретация сенсорного ввода и преобразование его в движение персонажа в мире.
- **Ключевые решения**:
  - *floating joystick* (`FloatingJoystick`): точка появления задаётся первым касанием, далее вычисляется вектор направления;
  - *deadzone*: мелкие движения пальца в пределах порога игнорируются, чтобы исключить дрожание;
  - нормализация и *clamp* силы: направление ограничено радиусом стика, что даёт стабильную шкалу \([-1..1]\).
- **Интеграция в цикл**:
  - в `GameScreen.update()` направление стика переводится в velocity (`playerVel`) с учётом множителей скорости из прогрессии;
  - позиция игрока ограничивается рамками арены через `MathUtils.clamp` (персонаж не может выйти за “карту”).

#### Подсистема таргетинга (выбор цели)

- **Ответственность**: выбор цели для авто‑атаки и удержание выбранной цели без “дёрганья”.
- **Ключевые решения** (`TargetingSystem`):
  - периодическое перенацеливание по таймеру (`retargetInterval`), чтобы не пересчитывать цель каждый кадр;
  - гистерезис (`hysteresisMul`): переключение на новую цель происходит только если она заметно ближе текущей, что повышает стабильность;
  - проверка валидности текущей цели (цель “отпускается” при смерти или выходе за дальность).
- **Интеграция в цикл**:
  - радиус таргетинга формируется на основе баланса (`Balance.cfg.targeting`) и апгрейдов дальности оружия;
  - результат таргетинга используется боевой подсистемой при генерации атак и визуально подсвечивается в рендере.

#### Боевая подсистема (снаряды, попадания, урон)

- **Ответственность**: хранение и обновление снарядов, проверка столкновений и применение урона.
- **Ключевые решения** (`CombatSystem`):
  - разделение на **снаряды игрока** и **снаряды врагов**;
  - столкновения по окружностям (радиус снаряда + радиус цели);
  - удаление снарядов при выходе за границы арены (с “маржином” из баланса);
  - поддержка механик **pierce** и **ricochet** как расширяемых модификаторов оружия (пробивание/рикошет с поиском следующей цели).
- **Интеграция в цикл**:
  - спавн снарядов выполняется на уровне `GameScreen` (с учётом оружия/кулдаунов/множителей), а перемещение и попадания — внутри `CombatSystem`;
  - при попадании вызывается callback `onEnemyHit(...)`, который используется для эффектов предметов‑триггеров (например, прок молнии).

#### Подсистема врагов и роста сложности

- **Ответственность**: поведение врагов, темп появления противников и эскалация сложности забега.
- **Сущности** (`Enemy`):
  - параметры здоровья, скорости, контактного урона, радиуса, наград (XP/gold);
  - тип врага (`EnemyKind`: normal/fast/tank/ranged), флаги `isElite`/`isBoss`;
  - поля минимальной системы статусов (замедление, стаки burn/bleed и таймеры).
- **Поведение** (`EnemySystem`):
  - базовое движение к игроку, а для дальников — удержание дистанции (в пределах min/max);
  - ограничения по арене (враг не уходит за границы);
  - дальняя атака через callback `spawnEnemyShot`, что отделяет логику врага от хранения снарядов.
- **Темп спавна** (`SpawnDirector`):
  - рост частоты спавна по времени (ramp), мягкий старт и “эндгейм‑спайк” перед финалом;
  - мягкое замедление темпа при высокой плотности врагов (crowd pressure) вместо жёсткого cap.
- **Интеграция в цикл**:
  - `GameScreen` запрашивает у `SpawnDirector` количество спавнов на кадр и создаёт врагов;
  - после достижения длительности забега запускается фаза босса, и обычные волны останавливаются.

#### Подсистема прогрессии (XP → LevelUp → выбор улучшений)

- **Ответственность**: накопление опыта, повышение уровня и формирование билда игрока.
- **Хранилище прогрессии** (`RunProgression`):
  - уровень, XP и порог до следующего уровня (кривая берётся из `Balance.cfg.progression`);
  - слоты билда: на текущем этапе **2 оружия + 2 кольца** (ограничение “2+2”);
  - глобальные бонусы (из святынь), которые не занимают слоты.
- **Механика LevelUp как “пауза”**:
  - при достижении нового уровня `GameScreen` переключает состояние на `LEVEL_UP`, замораживая мир;
  - игрок выбирает 1 из 3 карточек улучшений, после чего забег продолжается.
- **Генерация 3 карточек** (`UpgradeDirector`):
  - выбор без дубликатов и с гарантией релевантности (чтобы не выдавать “мусорные” варианты);
  - редкость (`UpgradeRarity`) задаёт шаг улучшения (1/2/4/7) и веса выпадения.

#### Подсистема лута и экономики забега

- **Ответственность**: награды за убийства, валюта забега, сундуки и выдача предметов.
- **Ключевые элементы** (`LootSystem`):
  - XP‑сферы и gold‑монеты со временем жизни (ttl) и “магнитом” подбора;
  - сундуки с ценой открытия (стоимость растёт по мере забега) и лимитами, предотвращающими “зарастание” карты;
  - автосрабатывание открытия сундука по близости при наличии золота.
- **Балансные решения**:
  - ограничения: максимум сундуков на карте и максимум обычных сундуков за забег;
  - рост цены: следующая стоимость сундука увеличивается (в MVP — удвоение), что регулирует экономику и силу второго канала усиления.
- **Интеграция в цикл**:
  - при смерти врага лут‑система создаёт XP/gold, а для элит — отдельный “элитный” сундук;
  - при открытии сундука выдаётся предмет, который добавляется в систему триггеров.

#### Подсистема предметов‑триггеров

- **Ответственность**: применение эффектов предметов как реакция на события (onHit/onKill/onDamageTaken/update).
- **Ключевые решения** (`ItemTriggerSystem`):
  - хранит активные предметы и их “состояние” (таймеры, готовность щита и т.п.);
  - использует лямбды для работы с врагами/уроном (без жёсткой зависимости от классов сущностей), что упрощает будущий рефакторинг.
- **Примеры эффектов**:
  - блокирование удара по кулдауну (щит);
  - токсичное облако после получения урона (периодический урон по области);
  - прок цепной молнии по попаданию.

#### Подсистема UI/HUD и оверлеев выбора

- **Ответственность**: отображение HUD, управление оверлеями выбора и обработка UI‑ввода.
- **Ключевые элементы**:
  - `RunUiSystem` отвечает за геометрию карточек, обработку тапов и рендер оверлеев (выбор персонажа, сложности, level‑up, святыни);
  - `GameScreen` рисует HUD (HP/уровень/валюта/слоты), кнопку паузы, а также дополнительные элементы (миникарта, босс‑бар).
- **UX‑решения**:
  - оверлеи завязаны на `RunState` и блокируют обновление мира, превращая выбор улучшений в отдельную фазу “принятия решения”;
  - интерфейс масштабируется параметром `uiScale`, что повышает читаемость на телефонах.

#### Взаимодействие подсистем в кадре (RUNNING)

В состоянии `RUNNING` `GameScreen` обновляет подсистемы в предсказуемом порядке: обработка ввода и перемещения → спавн/обновление врагов → лут и подбор ресурсов → статусы/DoT → снаряды и попадания → события (святыни) → проверка level‑up и переключение в оверлей. Такое упорядочивание снижает вероятность конфликтов (например, “поймать” level‑up в середине обновления мира) и упрощает отладку.

### 2.5 Проектирование data-driven контента и баланса

Для игр жанра *survivor-like* критична скорость итераций: игрок быстро ощущает изменения темпа спавна, урона, наград и читаемости UI. Поэтому в FactorLite часть параметров и контента проектируется как **data-driven слой**, который можно менять без переписывания игровой логики.

#### Почему баланс и контент должны жить в данных

Вынос параметров в данные даёт следующие преимущества:

- **быстрая балансировка**: изменение чисел (урон, кулдауны, кривая XP, темп спавна) не требует вмешательства в код подсистем;
- **снижение риска регрессий**: при корректной схеме и дефолтах изменения параметров меньше затрагивают архитектуру;
- **контроль версий**: конфиги живут в репозитории и изменяются через коммиты, поэтому легко сравнивать изменения и откатываться;
- **переносимость**: одинаковые конфиги используются на Desktop и Android благодаря общему `assets/`.

#### Формат конфигов: JSON и YAML

В проекте применяются два формата, решающие разные задачи:

- **JSON** — для “машиночитаемого” баланса, который загружается игрой напрямую. В FactorLite баланс хранится в `assets/data/balance.json` и считывается при старте через `Balance.loadOrKeepDefaults()`.
- **YAML** — для удобного редактирования и согласования контента в виде шаблонов/seed‑файлов. В текущем состоянии `docs/factorlite_content_seed.yaml` используется как документ‑черновик и основа для будущей формализации схемы контента.

Такое разделение позволяет иметь строгий, предсказуемый формат для рантайма (JSON), при этом сохраняя удобство “человеческого” редактирования и обсуждения (YAML).

#### Принципы версионирования и переносимости

При работе с конфигами важны совместимость и устойчивость:

- **дефолтные значения**: в коде определены значения по умолчанию, совпадающие с “зашитыми” числами, чтобы при отсутствии/повреждении файла поведение оставалось корректным;
- **обратная совместимость**: при чтении JSON включено игнорирование неизвестных полей, благодаря чему добавление новых параметров не ломает старые версии (подход “расширяем схему без падений”);
- **единый источник ассетов**: конфиги лежат в `assets/` и одинаково доступны на Desktop и Android, что исключает “расхождение баланса” между платформами.

#### Редактор контента (HTML): цели и сценарий использования

Для ускорения наполнения контентом в проекте добавлен локальный редактор `docs/content_editor.html`, который открывается без сервера и ориентирован на быстрые правки в духе “дизайнер‑дружелюбного” инструмента.

**Цели редактора**:

- быстро создавать/править сущности (оружие, пассивки, предметы сундуков, бонусы святынь);
- уменьшить количество ручной работы при подготовке конфигов;
- дать единый интерфейс для правок редкостей, весов и параметров “на шаг улучшения”.

**Сценарий использования**:

- пользователь добавляет/редактирует сущности в форме;
- состояние сохраняется в браузере (через `localStorage`), что позволяет продолжать работу позже;
- результат формируется справа в виде **YAML** (под шаблон/seed) и **JSON** (для дальнейшей интеграции).

**Экспорт**:

- копирование в буфер обмена (YAML/JSON);
- скачивание YAML‑файла (например, `factorlite_content.yaml`) для дальнейшей работы и переноса в репозиторий.

Таким образом, data-driven слой FactorLite формирует основу для дешёвых итераций по балансу и контенту: численные параметры и схемы расширяются через конфиги и инструменты, а код игровых подсистем остаётся стабильным и переиспользуемым.
